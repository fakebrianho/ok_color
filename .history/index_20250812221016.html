<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Brushed Photo Outline Effect</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 20px;
      background-color: #f0f0f0;
      font-family: Arial, sans-serif;
    }

    .controls {
      margin-bottom: 15px;
      display: flex;
      gap: 15px;
      align-items: center;
      flex-wrap: wrap;
    }

    .control-group {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    label {
      font-size: 14px;
      font-weight: bold;
    }

    input[type="range"] {
      width: 100px;
    }

    input[type="file"] {
      padding: 5px;
      border: 1px solid #ccc;
      border-radius: 3px;
    }

    button {
      padding: 8px 15px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
      font-size: 14px;
    }

    button:hover {
      background-color: #0056b3;
    }

    #sketch-container {
      border: 2px solid #ddd;
      border-radius: 5px;
      display: inline-block;
      background: white;
    }

    .brush-info {
      font-size: 12px;
      color: #666;
      margin-top: 5px;
    }
  </style>
</head>

<body>
  <h1>Brushed Photo Outline Effect</h1>
  <p>Upload an image to see it transformed with artistic brush-drawn outlines.</p>

  <div class="controls">
    <div class="control-group">
      <label for="fileInput">Upload Image:</label>
      <input type="file" id="fileInput" accept="image/*">
    </div>
    <div class="control-group">
      <label for="threshold">Edge Sensitivity:</label>
      <input type="range" id="threshold" min="0.1" max="1.0" step="0.05" value="0.4">
      <span id="thresholdValue">0.4</span>
    </div>
    <div class="control-group">
      <label for="brushSize">Brush Size:</label>
      <input type="range" id="brushSize" min="0.5" max="5.0" step="0.1" value="1.5">
      <span id="brushSizeValue">1.5</span>
    </div>
    <div class="control-group">
      <label for="brushOpacity">Brush Opacity:</label>
      <input type="range" id="brushOpacity" min="0.1" max="1.0" step="0.05" value="0.7">
      <span id="brushOpacityValue">0.7</span>
    </div>
    <div class="control-group">
      <label for="density">Brush Density:</label>
      <input type="range" id="density" min="1" max="10" step="1" value="4">
      <span id="densityValue">4</span>
    </div>
    <button onclick="redrawOutlines()">Redraw</button>
    <button onclick="saveImage()">Save Result</button>
    <button onclick="toggleOriginal()">Toggle Original</button>
  </div>

  <div class="brush-info">
    Brush strokes are drawn along detected edges with natural variation and texture
  </div>

  <div id="sketch-container"></div>

  <script>
    let img;
    let brushLayer;
    let edges = [];
    let threshold = 0.4;
    let brushSize = 1.5;
    let brushOpacity = 0.7;
    let density = 4;
    let showOriginal = false;
    let imageLoaded = false;
    let isDrawing = false;

    // Sample image data URL
    const sampleImageData = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAAdgAAAHYBTnsmCAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAFYSURBVBiVY/j//z8DJQAggBhJVQwQQIykKgYIIEZSFQMEECOpigECiJFUxQABxEiqYoAAYiRVMUAAMZKqGCCAGElVDBBAjKQqBgggRlIVAwQQI6mKAQKIkVTFAAHESKpigABiJFUxQAAxkqoYIIAYSVUMEECMpCoGCCBGUhUDBBAjqYoBAmANZAIAAYSNZgAAAABJRU5ErkJggg==";

    function preload() {
      img = loadImage(sampleImageData);
    }

    function setup() {
      let canvas = createCanvas(800, 600);
      canvas.parent('sketch-container');

      // Initialize brush layer
      brushLayer = createGraphics(width, height);
      brushLayer.background(255, 255, 255, 0);

      // Set up file input
      let fileInput = document.getElementById('fileInput');
      fileInput.addEventListener('change', handleFile);

      // Set up sliders
      setupSlider('threshold', (val) => { threshold = val; detectEdges(); });
      setupSlider('brushSize', (val) => { brushSize = val; });
      setupSlider('brushOpacity', (val) => { brushOpacity = val; });
      setupSlider('density', (val) => { density = parseInt(val); });

      imageLoaded = true;
      detectEdges();
    }

    function setupSlider(id, callback) {
      let slider = document.getElementById(id);
      let valueSpan = document.getElementById(id + 'Value');
      slider.addEventListener('input', function () {
        let val = id === 'density' ? parseInt(this.value) : parseFloat(this.value);
        valueSpan.textContent = val;
        callback(val);
      });
    }

    function handleFile(event) {
      let file = event.target.files[0];
      if (file && file.type.startsWith('image/')) {
        let reader = new FileReader();
        reader.onload = function (e) {
          img = loadImage(e.target.result, function () {
            imageLoaded = true;
            detectEdges();
          });
        };
        reader.readAsDataURL(file);
      }
    }

    function detectEdges() {
      if (!img || isDrawing) return;

      edges = [];

      // Resize image if too large
      let maxSize = 600;
      let workingImg = img;
      if (img.width > maxSize || img.height > maxSize) {
        let ratio = Math.min(maxSize / img.width, maxSize / img.height);
        workingImg = img.get();
        workingImg.resize(img.width * ratio, img.height * ratio);
      }

      // Load pixels for edge detection
      workingImg.loadPixels();
      let pixels = workingImg.pixels;
      let w = workingImg.width;
      let h = workingImg.height;

      // Find edges using simplified Sobel
      for (let x = 2; x < w - 2; x += 2) { // Skip pixels for performance
        for (let y = 2; y < h - 2; y += 2) {
          let gx = 0, gy = 0;

          // Simplified 3x3 Sobel
          let tl = getGrayValue(pixels, x - 1, y - 1, w);
          let tm = getGrayValue(pixels, x, y - 1, w);
          let tr = getGrayValue(pixels, x + 1, y - 1, w);
          let ml = getGrayValue(pixels, x - 1, y, w);
          let mr = getGrayValue(pixels, x + 1, y, w);
          let bl = getGrayValue(pixels, x - 1, y + 1, w);
          let bm = getGrayValue(pixels, x, y + 1, w);
          let br = getGrayValue(pixels, x + 1, y + 1, w);

          gx = (-tl + tr - 2 * ml + 2 * mr - bl + br);
          gy = (-tl - 2 * tm - tr + bl + 2 * bm + br);

          let magnitude = Math.sqrt(gx * gx + gy * gy) / 255;

          if (magnitude > threshold) {
            // Scale coordinates to canvas size
            let canvasX = map(x, 0, w, 0, width);
            let canvasY = map(y, 0, h, 0, height);

            edges.push({
              x: canvasX,
              y: canvasY,
              strength: magnitude,
              angle: Math.atan2(gy, gx)
            });
          }
        }
      }

      drawBrushStrokes();
    }

    function drawBrushStrokes() {
      if (!edges.length || isDrawing) return;

      isDrawing = true;
      brushLayer.clear();

      // Group nearby edges into stroke paths
      let strokes = [];
      let usedEdges = new Set();

      for (let i = 0; i < edges.length; i++) {
        if (usedEdges.has(i)) continue;

        let stroke = [edges[i]];
        usedEdges.add(i);

        // Find connected edges within a small radius
        let searchRadius = 15;
        let extended = true;

        while (extended && stroke.length < 20) {
          extended = false;
          let lastEdge = stroke[stroke.length - 1];

          for (let j = 0; j < edges.length; j++) {
            if (usedEdges.has(j)) continue;

            let dist = Math.sqrt(
              Math.pow(edges[j].x - lastEdge.x, 2) +
              Math.pow(edges[j].y - lastEdge.y, 2)
            );

            if (dist < searchRadius) {
              stroke.push(edges[j]);
              usedEdges.add(j);
              extended = true;
              break;
            }
          }
        }

        if (stroke.length > 2) {
          strokes.push(stroke);
        }
      }

      // Draw brush strokes
      brushLayer.strokeCap(ROUND);
      brushLayer.noFill();

      for (let stroke of strokes) {
        drawBrushStroke(stroke);
      }

      isDrawing = false;
    }

    function drawBrushStroke(strokePoints) {
      if (strokePoints.length < 2) return;

      // Draw multiple passes for brush texture
      let passes = Math.max(1, Math.floor(density / 2));

      for (let pass = 0; pass < passes; pass++) {
        let alpha = map(pass, 0, passes - 1, brushOpacity * 255, brushOpacity * 100);
        let weight = brushSize * random(0.7, 1.3);

        brushLayer.stroke(0, 0, 0, alpha);
        brushLayer.strokeWeight(weight);

        brushLayer.beginShape();
        brushLayer.noFill();

        for (let i = 0; i < strokePoints.length; i++) {
          let point = strokePoints[i];

          // Add natural variation to brush position
          let offsetX = random(-brushSize * 0.3, brushSize * 0.3);
          let offsetY = random(-brushSize * 0.3, brushSize * 0.3);

          if (i === 0) {
            brushLayer.vertex(point.x + offsetX, point.y + offsetY);
          } else {
            // Use curve vertices for smoother strokes
            brushLayer.curveVertex(point.x + offsetX, point.y + offsetY);
          }
        }

        brushLayer.endShape();
      }

      // Add some scattered brush marks for texture
      if (random() < 0.3) {
        for (let point of strokePoints) {
          if (random() < 0.5) {
            brushLayer.stroke(0, 0, 0, brushOpacity * 60);
            brushLayer.strokeWeight(brushSize * 0.5);
            brushLayer.point(
              point.x + random(-brushSize, brushSize),
              point.y + random(-brushSize, brushSize)
            );
          }
        }
      }
    }

    function getGrayValue(pixels, x, y, w) {
      let idx = (x + y * w) * 4;
      return (pixels[idx] + pixels[idx + 1] + pixels[idx + 2]) / 3;
    }

    function draw() {
      background(255);

      if (!img) return;

      // Calculate display size maintaining aspect ratio
      let displayWidth = width;
      let displayHeight = height;
      let imgRatio = img.width / img.height;
      let canvasRatio = width / height;

      if (imgRatio > canvasRatio) {
        displayHeight = width / imgRatio;
      } else {
        displayWidth = height * imgRatio;
      }

      let x = (width - displayWidth) / 2;
      let y = (height - displayHeight) / 2;

      if (showOriginal) {
        // Show original image
        image(img, x, y, displayWidth, displayHeight);
      } else {
        // Show faded original image
        tint(255, 180);
        image(img, x, y, displayWidth, displayHeight);
        noTint();

        // Overlay brush strokes
        image(brushLayer, 0, 0);
      }
    }

    function redrawOutlines() {
      if (imageLoaded) {
        detectEdges();
      }
    }

    function saveImage() {
      if (brushLayer) {
        save('brushed-outline.png');
      }
    }

    function toggleOriginal() {
      showOriginal = !showOriginal;
    }
  </script>
</body>

</html>