<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Brushed Photo Outline Effect</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 20px;
      background-color: #f0f0f0;
      font-family: Arial, sans-serif;
    }

    .controls {
      margin-bottom: 15px;
      display: flex;
      gap: 15px;
      align-items: center;
      flex-wrap: wrap;
    }

    .control-group {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    label {
      font-size: 14px;
      font-weight: bold;
    }

    input[type="range"] {
      width: 100px;
    }

    input[type="file"] {
      padding: 5px;
      border: 1px solid #ccc;
      border-radius: 3px;
    }

    button {
      padding: 8px 15px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
      font-size: 14px;
    }

    button:hover {
      background-color: #0056b3;
    }

    #sketch-container {
      border: 2px solid #ddd;
      border-radius: 5px;
      display: inline-block;
      background: white;
    }

    .brush-info {
      font-size: 12px;
      color: #666;
      margin-top: 5px;
    }

    select {
      padding: 5px;
      border: 1px solid #ccc;
      border-radius: 3px;
      background: white;
      font-size: 14px;
    }
  </style>
</head>

<body>
  <h1>Brushed Photo Outline Effect</h1>
  <p>Upload an image to see it transformed with artistic brush-drawn outlines.</p>

  <div class="controls">
    <div class="control-group">
      <label for="fileInput">Upload Image:</label>
      <input type="file" id="fileInput" accept="image/*">
    </div>
    <div class="control-group">
      <label for="threshold">Edge Sensitivity:</label>
      <input type="range" id="threshold" min="0.1" max="1.0" step="0.01" value="0.4">
      <span id="thresholdValue">0.4</span>
    </div>
    <div class="control-group">
      <label for="brushSize">Brush Size:</label>
      <input type="range" id="brushSize" min="0.5" max="5.0" step="0.1" value="1.5">
      <span id="brushSizeValue">1.5</span>
    </div>
    <div class="control-group">
      <label for="brushOpacity">Brush Opacity:</label>
      <input type="range" id="brushOpacity" min="0.1" max="1.0" step="0.01" value="0.7">
      <span id="brushOpacityValue">0.7</span>
    </div>
    <div class="control-group">
      <label for="density">Brush Density:</label>
      <input type="range" id="density" min="1" max="10" step="1" value="4">
      <span id="densityValue">4</span>
    </div>
    <div class="control-group">
      <label for="bgOpacity">Background Opacity:</label>
      <input type="range" id="bgOpacity" min="0.0" max="1.0" step="0.05" value="0.3">
      <span id="bgOpacityValue">0.3</span>
    </div>
    <div class="control-group">
      <label for="brushType">Drawing Style:</label>
      <select id="brushType">
        <option value="simple">Simple Lines</option>
        <option value="clean">Clean Outlines</option>
        <option value="pencil">Pencil</option>
        <option value="charcoal">Charcoal</option>
        <option value="ink">Ink Pen</option>
        <option value="crosshatch">Cross Hatch</option>
        <option value="stipple">Stipple</option>
        <option value="watercolor">Watercolor</option>
      </select>
    </div>
    <!-- <button onclick="redrawOutlines()">Redraw</button> -->
    <button onclick="saveImage()">Save Result</button>
    <button onclick="toggleOriginal()">Toggle Original</button>
  </div>

  <div class="brush-info">
    Choose from 8 different drawing styles: Simple Lines (basic outlines), Clean Outlines (smooth curves), plus 6
    artistic brush effects
  </div>

  <div id="sketch-container"></div>

  <script>
    let img;
    let brushLayer;
    let edges = [];
    let threshold = 0.4;
    let brushSize = 1.5;
    let brushOpacity = 0.7;
    let density = 4;
    let bgOpacity = 0.3;
    let brushType = 'simple';
    let showOriginal = false;
    let imageLoaded = false;
    let isDrawing = false;

    // Sample image data URL
    const sampleImageData = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAAdgAAAHYBTnsmCAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAFYSURBVBiVY/j//z8DJQAggBhJVQwQQIykKgYIIEZSFQMEECOpigECiJFUxQABxEiqYoAAYiRVMUAAMZKqGCCAGElVDBBAjKQqBgggRlIVAwQQI6mKAQKIkVTFAAHESKpigABiJFUxQAAxkqoYIIAYSVUMEECMpCoGCCBGUhUDBBAjqYoBAmANZAIAAYSNZgAAAABJRU5ErkJggg==";

    function preload() {
      img = loadImage(sampleImageData);
    }

    function setup() {
      let canvas = createCanvas(800, 600);
      canvas.parent('sketch-container');

      // Initialize brush layer
      brushLayer = createGraphics(width, height);
      brushLayer.background(255, 255, 255, 0);

      // Set up file input
      let fileInput = document.getElementById('fileInput');
      fileInput.addEventListener('change', handleFile);

      // Set up sliders
      setupSlider('threshold', (val) => { threshold = val; detectEdges(); });
      setupSlider('brushSize', (val) => { brushSize = val; if (imageLoaded) drawBrushStrokes(); });
      setupSlider('brushOpacity', (val) => { brushOpacity = val; if (imageLoaded) drawBrushStrokes(); });
      setupSlider('density', (val) => { density = parseInt(val); if (imageLoaded) drawBrushStrokes(); });
      setupSlider('bgOpacity', (val) => { bgOpacity = val; }); // This one doesn't need redraw
      setupSlider('bgOpacity', (val) => { bgOpacity = val; });

      // Set up brush type selector
      let brushSelect = document.getElementById('brushType');
      brushSelect.addEventListener('change', function () {
        brushType = this.value;
        if (imageLoaded) drawBrushStrokes();
      });

      imageLoaded = true;
      detectEdges();
    }

    function setupSlider(id, callback) {
      let slider = document.getElementById(id);
      let valueSpan = document.getElementById(id + 'Value');

      // Update on input (while dragging) for immediate feedback on display values
      slider.addEventListener('input', function () {
        let val = id === 'density' ? parseInt(this.value) : parseFloat(this.value);
        valueSpan.textContent = val;

        // Only update background opacity immediately (no redraw needed)
        if (id === 'bgOpacity') {
          callback(val);
        }
      });

      // Update on change (when released) for parameters that need redrawing
      slider.addEventListener('change', function () {
        let val = id === 'density' ? parseInt(this.value) : parseFloat(this.value);
        if (id !== 'bgOpacity') {
          callback(val);
        }
      });
    }

    function handleFile(event) {
      let file = event.target.files[0];
      if (file && file.type.startsWith('image/')) {
        let reader = new FileReader();
        reader.onload = function (e) {
          img = loadImage(e.target.result, function () {
            imageLoaded = true;
            detectEdges();
          });
        };
        reader.readAsDataURL(file);
      }
    }

    function detectEdges() {
      if (!img || isDrawing) return;

      edges = [];

      // Resize image if too large
      let maxSize = 600;
      let workingImg = img;
      if (img.width > maxSize || img.height > maxSize) {
        let ratio = Math.min(maxSize / img.width, maxSize / img.height);
        workingImg = img.get();
        workingImg.resize(img.width * ratio, img.height * ratio);
      }

      // Calculate how the image will be displayed on canvas
      let displayWidth = width;
      let displayHeight = height;
      let imgRatio = workingImg.width / workingImg.height;
      let canvasRatio = width / height;

      if (imgRatio > canvasRatio) {
        displayHeight = width / imgRatio;
      } else {
        displayWidth = height * imgRatio;
      }

      let displayX = (width - displayWidth) / 2;
      let displayY = (height - displayHeight) / 2;

      // Load pixels for edge detection
      workingImg.loadPixels();
      let pixels = workingImg.pixels;
      let w = workingImg.width;
      let h = workingImg.height;

      // Find edges using simplified Sobel
      for (let x = 2; x < w - 2; x += 2) { // Skip pixels for performance
        for (let y = 2; y < h - 2; y += 2) {
          let gx = 0, gy = 0;

          // Simplified 3x3 Sobel
          let tl = getGrayValue(pixels, x - 1, y - 1, w);
          let tm = getGrayValue(pixels, x, y - 1, w);
          let tr = getGrayValue(pixels, x + 1, y - 1, w);
          let ml = getGrayValue(pixels, x - 1, y, w);
          let mr = getGrayValue(pixels, x + 1, y, w);
          let bl = getGrayValue(pixels, x - 1, y + 1, w);
          let bm = getGrayValue(pixels, x, y + 1, w);
          let br = getGrayValue(pixels, x + 1, y + 1, w);

          gx = (-tl + tr - 2 * ml + 2 * mr - bl + br);
          gy = (-tl - 2 * tm - tr + bl + 2 * bm + br);

          let magnitude = Math.sqrt(gx * gx + gy * gy) / 255;

          if (magnitude > threshold) {
            // Map coordinates to actual display position on canvas
            let canvasX = displayX + map(x, 0, w, 0, displayWidth);
            let canvasY = displayY + map(y, 0, h, 0, displayHeight);

            edges.push({
              x: canvasX,
              y: canvasY,
              strength: magnitude,
              angle: Math.atan2(gy, gx)
            });
          }
        }
      }

      drawBrushStrokes();
    }

    function drawBrushStrokes() {
      if (!edges.length || isDrawing) return;

      isDrawing = true;
      brushLayer.clear();

      // Group nearby edges into stroke paths
      let strokes = [];
      let usedEdges = new Set();

      for (let i = 0; i < edges.length; i++) {
        if (usedEdges.has(i)) continue;

        let stroke = [edges[i]];
        usedEdges.add(i);

        // Find connected edges within a small radius
        let searchRadius = 15;
        let extended = true;

        while (extended && stroke.length < 20) {
          extended = false;
          let lastEdge = stroke[stroke.length - 1];

          for (let j = 0; j < edges.length; j++) {
            if (usedEdges.has(j)) continue;

            let dist = Math.sqrt(
              Math.pow(edges[j].x - lastEdge.x, 2) +
              Math.pow(edges[j].y - lastEdge.y, 2)
            );

            if (dist < searchRadius) {
              stroke.push(edges[j]);
              usedEdges.add(j);
              extended = true;
              break;
            }
          }
        }

        if (stroke.length > 2) {
          strokes.push(stroke);
        }
      }

      // Draw brush strokes
      brushLayer.strokeCap(ROUND);
      brushLayer.noFill();

      for (let stroke of strokes) {
        drawBrushStroke(stroke);
      }

      isDrawing = false;
    }

    function drawBrushStroke(strokePoints) {
      if (strokePoints.length < 2) return;

      switch (brushType) {
        case 'simple':
          drawSimpleStroke(strokePoints);
          break;
        case 'clean':
          drawCleanStroke(strokePoints);
          break;
        case 'pencil':
          drawPencilStroke(strokePoints);
          break;
        case 'charcoal':
          drawCharcoalStroke(strokePoints);
          break;
        case 'ink':
          drawInkStroke(strokePoints);
          break;
        case 'crosshatch':
          drawCrosshatchStroke(strokePoints);
          break;
        case 'stipple':
          drawStippleStroke(strokePoints);
          break;
        case 'watercolor':
          drawWatercolorStroke(strokePoints);
          break;
      }
    }

    function drawSimpleStroke(strokePoints) {
      // Basic single-pixel outlines - no brush effects
      for (let i = 0; i < strokePoints.length; i++) {
        let point = strokePoints[i];

        brushLayer.stroke(0, 0, 0, brushOpacity * 255);
        brushLayer.strokeWeight(brushSize);
        brushLayer.strokeCap(ROUND);

        // Just draw a simple point or very short line
        brushLayer.point(point.x, point.y);
      }
    }

    function drawCleanStroke(strokePoints) {
      // Smooth connected lines without texture
      if (strokePoints.length < 2) return;

      brushLayer.stroke(0, 0, 0, brushOpacity * 255);
      brushLayer.strokeWeight(brushSize);
      brushLayer.strokeCap(ROUND);
      brushLayer.strokeJoin(ROUND);
      brushLayer.noFill();

      // Connect points with smooth curves
      brushLayer.beginShape();
      for (let i = 0; i < strokePoints.length; i++) {
        let point = strokePoints[i];
        if (i === 0) {
          brushLayer.vertex(point.x, point.y);
        } else {
          brushLayer.curveVertex(point.x, point.y);
        }
      }
      brushLayer.endShape();
    }

    function drawPencilStroke(strokePoints) {
      // Light, sketchy pencil marks
      for (let i = 0; i < strokePoints.length; i++) {
        let point = strokePoints[i];
        let strokeAngle = point.angle + PI / 2;
        let numMarks = Math.max(1, Math.floor(density * 0.8));

        for (let mark = 0; mark < numMarks; mark++) {
          let alpha = map(mark, 0, numMarks - 1, brushOpacity * 180, brushOpacity * 60);
          let weight = brushSize * random(0.3, 0.8);
          let length = brushSize * random(2, 5);

          brushLayer.stroke(0, 0, 0, alpha);
          brushLayer.strokeWeight(weight);
          brushLayer.strokeCap(ROUND);

          let angleVariation = random(-0.4, 0.4);
          let actualAngle = strokeAngle + angleVariation;

          let startX = point.x + cos(actualAngle) * (-length / 2) + random(-brushSize * 0.7, brushSize * 0.7);
          let startY = point.y + sin(actualAngle) * (-length / 2) + random(-brushSize * 0.7, brushSize * 0.7);
          let endX = point.x + cos(actualAngle) * (length / 2) + random(-brushSize * 0.3, brushSize * 0.3);
          let endY = point.y + sin(actualAngle) * (length / 2) + random(-brushSize * 0.3, brushSize * 0.3);

          brushLayer.line(startX, startY, endX, endY);
        }
      }
    }

    function drawCharcoalStroke(strokePoints) {
      // Thick, soft charcoal marks
      for (let i = 0; i < strokePoints.length; i++) {
        let point = strokePoints[i];
        let strokeAngle = point.angle + PI / 2;
        let numMarks = Math.max(2, Math.floor(density * 1.5));

        for (let mark = 0; mark < numMarks; mark++) {
          let alpha = map(mark, 0, numMarks - 1, brushOpacity * 120, brushOpacity * 40);
          let weight = brushSize * random(1.5, 3.0);
          let length = brushSize * random(3, 8);

          brushLayer.stroke(0, 0, 0, alpha);
          brushLayer.strokeWeight(weight);
          brushLayer.strokeCap(ROUND);

          let angleVariation = random(-0.2, 0.2);
          let actualAngle = strokeAngle + angleVariation;

          let startX = point.x + cos(actualAngle) * (-length / 2) + random(-brushSize, brushSize);
          let startY = point.y + sin(actualAngle) * (-length / 2) + random(-brushSize, brushSize);
          let endX = point.x + cos(actualAngle) * (length / 2) + random(-brushSize * 0.5, brushSize * 0.5);
          let endY = point.y + sin(actualAngle) * (length / 2) + random(-brushSize * 0.5, brushSize * 0.5);

          brushLayer.line(startX, startY, endX, endY);
        }
      }
    }

    function drawInkStroke(strokePoints) {
      // Clean, precise ink lines
      if (strokePoints.length < 2) return;

      brushLayer.stroke(0, 0, 0, brushOpacity * 255);
      brushLayer.strokeWeight(brushSize * random(0.8, 1.2));
      brushLayer.strokeCap(ROUND);
      brushLayer.noFill();

      brushLayer.beginShape();
      for (let i = 0; i < strokePoints.length; i++) {
        let point = strokePoints[i];
        let offsetX = random(-brushSize * 0.1, brushSize * 0.1);
        let offsetY = random(-brushSize * 0.1, brushSize * 0.1);

        if (i === 0) {
          brushLayer.vertex(point.x + offsetX, point.y + offsetY);
        } else {
          brushLayer.curveVertex(point.x + offsetX, point.y + offsetY);
        }
      }
      brushLayer.endShape();
    }

    function drawCrosshatchStroke(strokePoints) {
      // Cross-hatched drawing style
      for (let i = 0; i < strokePoints.length; i++) {
        let point = strokePoints[i];
        let strokeAngle = point.angle + PI / 2;

        // Primary hatch direction
        for (let mark = 0; mark < density; mark++) {
          let alpha = brushOpacity * random(100, 200);
          let weight = brushSize * random(0.4, 0.7);
          let length = brushSize * random(2, 4);

          brushLayer.stroke(0, 0, 0, alpha);
          brushLayer.strokeWeight(weight);

          let startX = point.x + cos(strokeAngle) * (-length / 2);
          let startY = point.y + sin(strokeAngle) * (-length / 2);
          let endX = point.x + cos(strokeAngle) * (length / 2);
          let endY = point.y + sin(strokeAngle) * (length / 2);

          brushLayer.line(startX, startY, endX, endY);

          // Cross hatch
          if (random() < 0.6) {
            let crossAngle = strokeAngle + PI / 3;
            let crossStartX = point.x + cos(crossAngle) * (-length / 3);
            let crossStartY = point.y + sin(crossAngle) * (-length / 3);
            let crossEndX = point.x + cos(crossAngle) * (length / 3);
            let crossEndY = point.y + sin(crossAngle) * (length / 3);

            brushLayer.stroke(0, 0, 0, alpha * 0.7);
            brushLayer.line(crossStartX, crossStartY, crossEndX, crossEndY);
          }
        }
      }
    }

    function drawStippleStroke(strokePoints) {
      // Stippled/dotted drawing style
      for (let i = 0; i < strokePoints.length; i++) {
        let point = strokePoints[i];
        let numDots = Math.max(3, Math.floor(density * 2));

        for (let dot = 0; dot < numDots; dot++) {
          let alpha = brushOpacity * random(150, 255);
          let dotSize = brushSize * random(0.3, 1.2);

          brushLayer.stroke(0, 0, 0, alpha);
          brushLayer.strokeWeight(dotSize);

          let dotX = point.x + random(-brushSize * 1.5, brushSize * 1.5);
          let dotY = point.y + random(-brushSize * 1.5, brushSize * 1.5);

          brushLayer.point(dotX, dotY);
        }
      }
    }

    function drawWatercolorStroke(strokePoints) {
      // Soft, flowing watercolor style
      for (let i = 0; i < strokePoints.length; i++) {
        let point = strokePoints[i];
        let strokeAngle = point.angle + PI / 2;
        let numMarks = Math.max(2, Math.floor(density * 1.2));

        for (let mark = 0; mark < numMarks; mark++) {
          let alpha = map(mark, 0, numMarks - 1, brushOpacity * 80, brushOpacity * 20);
          let weight = brushSize * random(2.0, 4.0);
          let length = brushSize * random(4, 10);

          brushLayer.stroke(0, 0, 0, alpha);
          brushLayer.strokeWeight(weight);
          brushLayer.strokeCap(ROUND);

          let angleVariation = random(-0.6, 0.6);
          let actualAngle = strokeAngle + angleVariation;

          let startX = point.x + cos(actualAngle) * (-length / 2) + random(-brushSize * 1.5, brushSize * 1.5);
          let startY = point.y + sin(actualAngle) * (-length / 2) + random(-brushSize * 1.5, brushSize * 1.5);
          let endX = point.x + cos(actualAngle) * (length / 2) + random(-brushSize, brushSize);
          let endY = point.y + sin(actualAngle) * (length / 2) + random(-brushSize, brushSize);

          brushLayer.line(startX, startY, endX, endY);
        }
      }
    }

    function getGrayValue(pixels, x, y, w) {
      let idx = (x + y * w) * 4;
      return (pixels[idx] + pixels[idx + 1] + pixels[idx + 2]) / 3;
    }

    function draw() {
      background(255);

      if (!img) return;

      // Calculate display size maintaining aspect ratio
      let displayWidth = width;
      let displayHeight = height;
      let imgRatio = img.width / img.height;
      let canvasRatio = width / height;

      if (imgRatio > canvasRatio) {
        displayHeight = width / imgRatio;
      } else {
        displayWidth = height * imgRatio;
      }

      let x = (width - displayWidth) / 2;
      let y = (height - displayHeight) / 2;

      if (showOriginal) {
        // Show original image
        image(img, x, y, displayWidth, displayHeight);
      } else {
        // Show faded original image with adjustable opacity
        tint(255, bgOpacity * 255);
        image(img, x, y, displayWidth, displayHeight);
        noTint();

        // Overlay brush strokes
        image(brushLayer, 0, 0);
      }
    }

    function redrawOutlines() {
      if (imageLoaded) {
        detectEdges();
      }
    }

    function saveImage() {
      if (brushLayer) {
        save('brushed-outline.png');
      }
    }

    function toggleOriginal() {
      showOriginal = !showOriginal;
    }
  </script>
</body>

</html>